# stark language

# this is a comment

#(
this
is
a
mount-ligned
comment
)#

import std.*

def main : fn(); {
  def constant : add_but_a_macro(4, 5);  # for constants definitions use ':', functions, struct, macros and all that are technically all constants
  def variable = 2; # for variables use '=', type is infered
  def variable2 = i32 7; # use a specific type
  def variable3 = i32; # only declaration
  def result = add(variable, variable2);
  if result == 9 print("something");
  if result == { # sort of a switch statement
    9: {
      print("this");
    }
    10: print("that");
  }
}

def add_i32 : fn(i32 a, b) i32; return a + b; # everything is statement base, so a function and everything else requires only a statement
def add_i64 : fn(i64 a, b) i64; return a + b;
def add : fn_overload(add_i32, add_i64) # explicit function overloading

def bar : fn(i32 a, b, i64 c, d, e) i64; return i64(a + b) + c + d + e; # if type not specified for argument it takes from the previous one

def div : fn(i32 a, b) i32, bool; return b == 0 ? (0, false) false : (a / b, true); # multiple returns

def sub : fn(i32 a, b) i32; {
  def result = a - b;
  return result;
} # for multiple statements enclose them with {}

prv def hello : fn(); print("hello, world") # private function, everything by default is public and will be exported as a 'module'

def add_but_a_macro : macro(i32 a, b) i32; return a + b;   # macros with type-safety

def Something : struct() {
  i32 x, y;
  i64 z;
}

def Vec2 : struct(f32 x, y, z) { # you can pass initializing arguments to a struct
  f32 x = x,
      y = y,
      z = z;
}

def vec2_add : fn(Vec2 *a, b) Vec2; return Vec2(a.x + b.x, a.y + b.y, a.z + b.z);
def vec2_sub : fn(Vec2 *a, b) Vec2; return Vec2(a.x - b.x, a.y - b.y, a.z - b.z);
def vec2_mul : fn(Vec2 *a, b) Vec2; return Vec2(a.x * b.x, a.y * b.y, a.z * b.z);
def vec2_div : fn(Vec2 *a, b) Vec2; return Vec2(a.x / b.x, a.y / b.y, a.z / b.z);
operator(+, vec2_add); # operation overloading
operator(-, vec2_sub);
operator(*, vec2_mul);
operator(/, vec2_div);

def Array : struct(type T) { # generic type on struct, can be acessed through array.T (or the whatever the chosen name) as a constant
  i32 size;
  T *buffer;
}

def array_get : fn(Array *arr, i64 index) arr.T; return &arr.buffer[index]; # generic function based on a generic struct
operator([], array_get)

def mul : fn($T a, b) $T; return a * b; # generic function (T can be whatever name you want)


I'm making a language and created a replacement for std::vector or Vec. It's called Tape. It's a dynamic array that doesn't grow it's capacity. It has three backends for memory: the heap (virtual memory), static (memory that's embedded on the executable binary) and the stack. When creating the Tape you call an specialized function to which version that you want. If the capacity provided is 0 it's set to an default value: 4GiB for virtual memory on 64bit machines (~0.003%), 32MiB for virtual memory on 32bit machines (~0.8%), 32MiB for static memory and 4KiB for stack memory. The capacity for virtual memory is always aligned to the page size.

The API for the Tape is just as high-level as std::vector or Vec, you can push, pop, insert, remove, etc. All of them extremely efficient and you never have to worry about reallocations (only when you explicitly want to and are awhere of the tradeoffs), so pointer stability is guaranteed.

If you're working on an extremely limited system you can dynamically grow the capacity using the function `grow_cap_kill_ptrs`. The name is verbose to reinforce that most of the time you don't need said function. You pass an amount to grow, this amount is going to be aligned to page size. This function panics if used on static or stack backends. There is also `push_might_kill_ptrs`/`insert_might_kill_ptrs`, it combines `grow_cap_kill_ptrs` with the standard `push` and `insert`, this way classic `std::vector`/`Vec` behavior is achieved, but it's heavily discourage and not the default.

Because the default heap memory is tuned to the machine (32MiB for 32bit and 4GiB for 64bit) and because there's 0 memory fragmentation memory wastage is actually less then `std::vector` or `Vec` funnily enough.

The API is as ergonomic as `std::vector`/`Vec` and you can have the "just works" functionality. When using the default `Tape.make(T)` the `Tape` will be allocated on the heap with the default capacity. If you're on the "just works" realm for prototyping or are a beginner then you definitely are on a x64 machine or at least are on an x86 and don't need more than 32MiB of memory. Either way it can be just as ergonomic as `std::vector`/`Vec`

`Tape` is actually more beginner friendly as well. When a vector reallocates a beginner wouldn't understand why their pointers are getting invalidated and why there are bugs on their code out of nowhere. Because pointer invalidation is simply impossible unless you actively state to (`grow_cap_kill_ptrs`) this is not a problem. 

imo this is much better than std::vector or Vec. The only tradeoff is manual capacity growth, and if we are being honest that's not really a tradeoff, if you're on a limited system that requires this you often _want_ the control of capacity explicitly.

With `Tape`, `std::vector`/`Vec` becomes obsolete. Languages like C++ and Rust are focused on low level programming, thus the little bit of "verbosity" (it'll actually just be as simple as `some_tape.push_might_kill_ptrs(10);`, and this is only on very limited hardware and most of the time you will not be doing this) is not an excuse for using them instead of `Tape`, a much more powerful and performant approach.

There is no tradeoffs on using `Tape`s compared to using `std::vector`/`Vec`. Unless you consider explicitness and intent a tradeoff, that would be weird.

`Tape` isn't just a dynamic array, though. It can and should be used as one, but keep in mind that because the OS virtual memory mapper is used directly it always has at least one page of capacity and this page will be commited uppon usage. On serious applications and not just prototyping you should use `Tape` as a typed arena allocator. It has more capabilities than a normal arena allocator because it has knowledge of it's type. This is quite a paradigm shift, but in the long it's easier and far more performant than using a normal `std::vector`/`Vec`, it's just a mather of grown used to, like programmers do when learning how to code. It may seem like a huge tradeoff at first, but it's not, just think as learning to program again in a much lower extant. With a simple project or two, this becomes natural and it's seems pretty counter intuitive to do it the regular way that C++ or Rust preaches.

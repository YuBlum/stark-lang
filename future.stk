# stark language

# this is a comment

#(
this
is
a
mount-ligned
comment
)#

import std.*

def main : fn(); {
  def constant : add_but_a_macro(4, 5);  # for constants definitions use ':', functions, struct, macros and all that are technically all constants
  def variable = 2; # for variables use '=', type is infered
  def variable2 = i32 7; # use a specific type
  def variable3 = i32; # only declaration
  def var0, var1 = 0, 1; # multi variable declarations
  def var2, var3 = i32 0, i32 1; # multi variable with explicit types
  def var2, var3 = i32, i32; # multi variable with explicit types, but not assignment
  def var4, var5 = i32; # multi variable declaration with one type for wall variables
  def var6, var7 = i32 2, 3; # multi variable with explicit types, with assignment and decay to previous type for the other variables
  def var8, var9, var10, var 11 = i32 4, 6, i64 8, 10; # is also possible
  def result = add(variable, variable2);
  if result == 9 print("something");
  if result == { # sort of a switch statement
    9: {
      print("this");
    }
    10: print("that");
  }
}

def add_i32 : fn(i32 a, b) i32; return a + b; # everything is statement base, so a function and everything else requires only a statement
def add_i64 : fn(i64 a, b) i64; return a + b;
def add : fn_overload(add_i32, add_i64) # explicit function overloading

def bar : fn(i32 a, b, i64 c, d, e) i64; return i64(a + b) + c + d + e; # if type not specified for argument it takes from the previous one

def div : fn(i32 a, b) i32, bool; return b == 0 ? (0, false) false : (a / b, true); # multiple returns

def sub : fn(i32 a, b) i32; {
  def result = a - b;
  return result;
} # for multiple statements enclose them with {}

prv def hello : fn(); print("hello, world") # private function, everything by default is public and will be exported as a 'module'

def add_but_a_macro : macro(i32 a, b) i32; return a + b;   # macros with type-safety

def Something : struct() {
  def x, y = i32;
  def z = i64;
  def constant : 10; # a constant that can be acessed by all instances of Something as a compile time value
}


def Person : struct(i32 age, *u8 name) {
  def age, name = age, name;
  def say_hi : fn(*SomethingNew self) => print("Hi, my name is ", self.name, "I'm ", self.age, " years old") # say_hi is a constant so it has the same behaviour as the constant on Something
}

def test_person : fn() => {
  jon = Person(14, "Jon");
  Person.say_hi(&jon) # calling the constant function inside the structure
  jon.say_hi(&jon); # can also be called via a instance
  jon:say_hi(); # pagin the instance implitly
}

def Point : struct() => def x, y = i32;

def Vec2 : struct(f32 x, y, z) { # you can pass initializing arguments to a struct
  def x, y, z = f32 x, y, z;
  def add : fn(*Vec2 self, other) Vec2 => Vec2(self.x + other.x, self.y + other.y, self.z + other.z);
  def sub : fn(*Vec2 self, other) Vec2 => Vec2(self.x - other.x, self.y - other.y, self.z - other.z);
  def mul : fn(*Vec2 self, other) Vec2 => Vec2(self.x * other.x, self.y * other.y, self.z * other.z);
  def div : fn(*Vec2 self, other) Vec2 => Vec2(self.x / other.x, self.y / other.y, self.z / other.z);
}
operator + Vec2.add; # operation overloading -> basically is an alias for Vec2.add
operator - Vec2.sub;
operator * Vec2.mul;
operator / Vec2.div;

def List : struct(type T) {
  i32 size;
  T *buffer;
  def get : fn(List *arr, i64 index) T => return &arr.buffer[index];
}
operator [] List.get;

def mul : fn($T a, b) $T; return a * b; # generic function (T can be whatever name you want)

